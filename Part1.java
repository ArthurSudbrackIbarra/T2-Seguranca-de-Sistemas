import java.math.BigInteger;
import java.security.SecureRandom;

/**
 * Part1
 */
public class Part1 {

    // Main
    public static void main(String[] args) {
        // [PARTE 1] Gerar chaves assimétricas

        // Gerar dois números primos p e q com no mínimo 1024 bits
        BigInteger p = BigInteger.probablePrime(1024, new SecureRandom());
        BigInteger q = BigInteger.probablePrime(1024, new SecureRandom());

        // Calcular Na = p.q
        // ! na = 00CC0A42C0A1F3AC0F024E44DCC1756B478F2AC4093873384DBF745B84908DB82D0861D68C89B327E62126343D409DFC46EF312BB8E9FE643CD6879FA18B17B905C37FD144332397F873A91329B891C392B34DD50A9D8FB5E2B47DC6DCEF75443BD6FFA44539C22A09BA1E5BAB518BFEDCEB3703BADEB5B91F5F6669E089B9F559DFD1AC6DEB2FD9D0E2B3B2E2D018F08E696FEC479A5D9688EAAA55FFE8596CC6EBFDBB13AB5A72C89CDB375A6A5B26160EDAE68C30A63401AC22DCE3FABB32668F6C86A3E4CD38199885F836CFFDBA54DF3BAF5B1F76A2C3C8A7334785A304BBEB0A1634F736A583B57FE0619CA3C96B16F4D70118EBEB5B6F2A04740F0E79BD
        // ! na2 = 00959FEBE9936E0A531F8D69699BDF30E895438E01A661A7202E4DC02A4F1CEDF1E6944AAB16028166E8A600121CFA8862D97A72FB5D8C0ADF9973B36EB589222646FB26F3C5BA08B0DC1728F2BC752A6F79D751908642471CA3A597924AFD32B78C0B1A5757E79BE67E1693409D4182028A46CEBBC5460F23D09AE6F2FDDB81C959429E22AAC35918B9B3CC193C254BE6E02E36B79E765A0CF161DC75341D23A4DDC3BD11718E6EDD70B3855C2D6FAC0594E0131006F89596C873A69F1F7F5A61654A0D1C346D7A1F4836F536A279931E78D4EFE7C9F1D6ADC971797E6F59A0DB18061E096AAF5F0E43E64262B9831882B08D590A79E305A14D04F2BC18062B7F
        BigInteger na = p.multiply(q);

        // Calcular L = (p-1).(q-1) -> função j de Euler
        BigInteger l = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));

        // Encontrar um ea que seja primo relativo de L, ou seja, MDC(ea, L) = 1
        // ! ea = 00EF5CEBF07C916F592087FC5373FC0F2A34A9DEAE44844C173324227D60FFCFB7861E1E6AC49FF2318432E5C7875782B860AEEB50EABC9A34F487449FA4E7A11628C23247ABEACECE66C216C8E1410FCAFD9E68638A8C3C9E3C990FFF383B58FE8BF766A8CBDB676230E2DF3ADF99B244F19303BB5C4BF8AAEB11C9DC5B06F1FD
        // ! ea2 = 594F56F6D2DC03C2CFE7ECBC0A0DD9373B89536FC0041869E9B22347EC116B7AB69F8A36E68D60C02E387DA3B10F6718C368DD420B1AF1FD3F6934D05571782B750B3E283D0EE3CDB6FDA48C27B7E7499D4EA5158C6F49FBD9D64D3A7650127788B2D7DDB35BD953B099D282B2A813B2480C1C82219AA392D4390276CFDC67D835B726AFDFD4CF0C4B047E7C06860457B054C8AE54E9B98C41191C0F3622236F750ADCA33EEABFEF3887294134915CDA24DFF6D4335C3922F0576D4E2CA7F8B41D078681D24911F1B15AB7F5FC4544DF2BA2A30F01B54C1733949FC2F0BC562AD24BDCACD73D16B3B0E04DF60535564AE4A59B512CC042815BFF67E5262B6E89
        BigInteger ea = findRelativePrime(l);
        System.out.println(l.bitLength() + " bits");

        // Calcular o inverso da de ea em ZL, ou seja, da.ea = 1 em ZL
        // ! da = 67AFF4F1A4FEA20D75716EB7A99277D616E51A8695EAA49D6AFF50A8D9C951D6CE96F3015C1FBE81B29DB68EFB1B58D5F65F516B9538AF01E9B907B916497EA9FAC0A164949B885F493A92AFFE22331A156A84E1169FEA4263310DC06129F026ABF205C29C02C271563779F70EA082605BE228340F849FC2867C6D5C9CE6DA912DC5A1F882D6D5E0593EBB7EA6942533C10B4684B87167E93C415B3E7D9987FB4CCD2CB496EA5AF32A25AED2C6BFCF269320C15298A405307F6E6531F054BDB905BAF94421BE992C5CF022982E78C91E252DF1A09F1561C47912B5E80AEA0BAE31C2EF7438F256B0704DB9C84DF0BC0719E13F02EB2D16A2415D1D8AD8D97285
        // ! da2 = 00D5D5338E70342759DC7780F0CC0284558B64CC1756AA33C9E1B5035DF514237BC37CFAF76915773FE1AD945CBC2CBD69D52C1FE54D5611E11923FAC9C016EF2746A0BBDCAFEAA114B40F6EF3608CD048D61B52BE13E37E7F5C99519020D95D9A2B54C1255E72DF08012BC54519E39169E5067B46AA6F4C16A3ED297D72DB5C8D6B3CFD39527367F6593F7C1535CCF7A65DFF591B3634A078E0630501753CF4DB8D91BAFE27D95A399E134827B826A1566E2AE1744E5B334FE0002756434FB7C38B00F58CF6B0E2BB79E58A720DBCE5451D765A983DFF0BA9B144970AE862683AE81A88CC3091A8897BA0DAAC530563412F553F9C47D7D5BE51EB8721B4B8CA1
        BigInteger da = ea.modInverse(l);

        // Guardar a chave pública pka = (ea, Na) e a chave privada ska = (da, Na)

        // [PARTE 2] Gerar chave simétrica, Cifrar chave simétrica, Assinar texto
        // cifrado

        // Escolher um valor aleatório s de 128 bit -> chave a ser usada no AES
        // ! s = 00C271F4268C211B12FA4E700DD7DA1042
        // ! s2 = 1C6F5ACA62B8C4A736AC8CF66B797C5C
        BigInteger s = new BigInteger(128, new SecureRandom());

        // Calcular x = s^ep mod Np -> cifra a chave usando a chave pública do professor
        // ! x = 1505ABB0D8F5CDC6277C94FF922294BD18FD4E04415E4928A9E4651C9FDCADA16D9C5BFCCE63297C35EDA80F95C394B8F7193AA7FA042B9564E378FC4ABA362FE5F7824B2FB9A91AC3607EBECAE991BB09300A982797F68F78087252C42439BCE39609427EF691224DE00F508D8E703A5B69F57EDB46D45C4AF26E37085899F6892E7A2DA383CDE0A6070A308D24EEAF29923F08DF51F823A0C8F70AFF1AE8BE61FE2F3BDA9C5295EE6E7F93EB8D49581BBA930B7FE7C4287D9FF78E33E68F8548818D1B40697FADF9C088C34F46851B114B103AAC4425B4A18C092193F1FB423A95E3C8D18AEE9F0067CCA294CF8E96C97117BDF013E41EBC2F271B44C6AB84
        // ! x2 = 13E6CB02567B52FDF6E5A666E206B04D761A9E6D955E3CBA234D6FB0FD9AD7C034EF52C6176637BDC22100F0FDA76BE4CD4329ABC9A010F0DE5A964D1FAE899A91880132D62874878F7FC0DE920826B132AA2F7340D189BA2B4CECCE1B345EDDEC5777DFC3F44B560AA571FD5E4CFE0E73EEBCFA7DCFD0DA4B22C6C5A71BE4106F4523DE85B76D7169D888EA48FD1CEBFF535A077AE96D75B5626838E55B8E2A9ADE2A9ACF0E71B2A6BDE61A13C9D33EE56C76DC55716452E5E68FDB82C9360E0AE4CE14CB45606EBAC6F5F3D1F004105BF7B2BD242F90553C6234F6C27F9134493C3D70C850ED00C29810DB79C41EA5C8C76BFCF1AAC75D24010C45A899AC06
        BigInteger x = s.modPow(Constants.epTeacher, Constants.npTeacher);

        // Calcular sigx = x^da mod Na -> assina a mensagem usando a chave privada do
        // aluno
        // ! sigx = 2D9F31DA3AF6BC2CF0BC1CA115D3423C0FB73CF3DA64A09223AE17A25ED59C736659ABFA3B1AD177A74CAA2747A04AC536A48B28D6BE714DE23C74E5025D3518161C69A8703320E4ABA1E75A6B8A27FB5DE4D17805301920B896996A9F16ED99CD8E5BBF08062CA3A3CE7370C8BE6DA73149A165076C6D20F8F02B6DB2224A9DA5E22D044780286CF45A8BC477D1BAF5FF006F7229F3B77E59F51450FD86D58AC823AB34699734B5F3C5FE2B21DE0CD1B70312926BB673EC26A891D34F698E57BF95043A445565129ED68C0C113FD9491D6E22E63443A97412345DF2DB235405E9A21A0D681EA6127AE4FBE4150312761C3997DBAC6F35E32F47EE3DF8D5900E
        // ! sigx2 = 38ACF26928A238D65960E894D58C1B26D9ACA1BAAA07898421F7020CA95AB2612F33C76B1EAEEA6E93F6D29004E4AB5D224A9B3E29EC7DA24601A4DA20011F8B91026009F70FD39DF17707C69B4268B66514711CAE7E843310E1C27EA50DC5BE49E070F0112C883AB7AEA9A3BE4FE107C7CD789C8F8C7CB933E5D755DF3B7DA8C4E148BC6BFA5976193AE5684ED0BC65FF5523C050A48C907BB6976F0709CC3006F8F9064217117AB96418208C73697E654AB00A3DAA853BF17464802D7C4ACF82182C400E1557C4BB0C2E6974EAC4DF88C9DF93DF389ADC20A478E717BC7BF59B33FD5BF1AD0F6C7CB9A136573009E1DCDFC1D7D80F065FD51EE6E94113DD9F
        BigInteger sigx = x.modPow(da, na);

        // Enviar (x, sigx, pka) para o professor por email ou whatsapp -> todos os
        // valores em hexadecimal
        System.out.println("=== Dados a serem enviados para o professor (em hexadecimal) ===\n");
        System.out.println("x: " + bigIntegerToHex(x) + "\n");
        System.out.println("sigx: " + bigIntegerToHex(sigx) + "\n");
        System.out.println("ea: " + bigIntegerToHex(ea) + "\n");
        System.out.println("na: " + bigIntegerToHex(na));

        // Printar os valores que ficam com o aluno
        System.out.println("\n=== Valores que ficam com o aluno (em hexadecimal) ===\n");
        System.out.println("s: " + bigIntegerToHex(s) + "\n");
        System.out.println("da: " + bigIntegerToHex(da));
    }

    // Método auxiliar para encontrar um número primo relativo a L
    public static BigInteger findRelativePrime(BigInteger l) {
        BigInteger ea;
        do {
            ea = new BigInteger(l.bitLength(), new SecureRandom());
        } while (!ea.gcd(l).equals(BigInteger.ONE) || ea.compareTo(BigInteger.ONE) <= 0 || ea.compareTo(l) >= 0);
        return ea;
    }

    // Método auxiliar para receber um BigInteger e retornar o valor em hexadecimal.
    public static String bigIntegerToHex(BigInteger value) {
        String hex = value.toString(16).toUpperCase();
        // Adicionar um byte 0 no início se o valor começar com {8, 9, A, B, C, D, E, F}
        if (hex.matches("^[89A-F].*")) {
            hex = "00" + hex;
        }
        return hex;
    }
}
